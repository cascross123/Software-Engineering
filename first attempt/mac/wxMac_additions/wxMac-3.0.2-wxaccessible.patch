From 5335be70342fa635304bdbf7839ecb8c99e5333e Mon Sep 17 00:00:00 2001
From: Paul Licameli <paul.licameli@audacityteam.org>
Date: Thu, 28 Jul 2016 14:36:27 -0400
Subject: [PATCH] Implement parts of NSObject(NSAccessibility) informal
 protocol

Make wxNS* classes interact better with Xcode debugger

wxUSE_ACCESSIBILITY compiles on Mac

Methods in wxOSXCocoa classes intercept OSX 10.6 accessibility protocol

Define proxy class wxAccessibilityChild

Implement notifications, as best we can for the mismatch of codes

Implement accessibilityIsIgnored -- always false when any wxAccessible

Scaffolding to query, get, set standard NSAccessibility attributes

Implement role, subrole, and role description attributes

Implement string-valued standard attributes

Implement the three children attributes

Implement the parent attribute

Implement window and top-level element attributes

Implement the size and position attributes

Implement the focused, selected, enabled, etc. status attributes

Implement wxAccessible default actions
---
 include/wx/access.h     |   14 +
 include/wx/chkconf.h    |    2 +-
 src/osx/cocoa/window.mm | 1854 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 1869 insertions(+), 1 deletion(-)

diff --git a/include/wx/access.h b/include/wx/access.h
index 70cbaf1..3cdbd7c 100644
--- include/wx/access.h
+++ include/wx/access.h
@@ -370,6 +370,20 @@ private:
     #include "wx/msw/ole/access.h"
 #endif
 
+#if defined(__WXMAC__)
+
+class WXDLLIMPEXP_CORE wxAccessible : public wxAccessibleBase
+{
+public:
+   wxAccessible(wxWindow *win = NULL) : wxAccessibleBase(win) {}
+   virtual ~wxAccessible() {}
+
+   static void NotifyEvent
+   (int eventType, wxWindow* window, wxAccObject objectType, int objectId);
+};
+
+#endif
+
 #endif // wxUSE_ACCESSIBILITY
 
 #endif // _WX_ACCESSBASE_H_
diff --git a/include/wx/chkconf.h b/include/wx/chkconf.h
index 47fa8ee..a1c6857 100644
--- include/wx/chkconf.h
+++ include/wx/chkconf.h
@@ -1469,7 +1469,7 @@
  */
 #if wxUSE_GUI
 
-#if wxUSE_ACCESSIBILITY && !defined(__WXMSW__)
+#if wxUSE_ACCESSIBILITY && !( defined(__WXMSW__) || defined(__WXMAC__) )
 #   ifdef wxABORT_ON_CONFIG_ERROR
 #       error "wxUSE_ACCESSIBILITY is currently only supported under wxMSW"
 #   else
diff --git a/src/osx/cocoa/window.mm b/src/osx/cocoa/window.mm
index 881d0e9..5cf7c23 100644
--- src/osx/cocoa/window.mm
+++ src/osx/cocoa/window.mm
@@ -18,6 +18,7 @@
     #include "wx/combobox.h"
     #include "wx/radiobut.h"
     #include "wx/button.h"
+    #include "wx/hashset.h"
 #endif
 
 #ifdef __WXMAC__
@@ -39,6 +40,7 @@
 #endif
 
 #include <objc/objc-runtime.h>
+#include "wx/cocoa/string.h"
 
 // Get the window with the focus
 
@@ -939,6 +941,22 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text);
 @end // wxNSView(TextInput)
 
 
+// An objective-C object that can be returned to Cocoa to receive the
+// callbacks for accessibility, in case its parent defines it as an accessible
+// sub-element that does not correspond to an entire wxWindow.
+@interface wxAccessibilityChild : NSObject
+{
+   wxAccessible *accessible;
+   NSInteger number;
+}
+
+- (id)initWithAccessible: (wxAccessible*)accessible_
+               andNumber: (NSInteger)number_;
+
++ (id)accessibilityChildWithAccessible: (wxAccessible*)accessible_
+                             andNumber: (NSInteger)number_;
+@end
+
 //
 // event handlers
 //
@@ -984,8 +1002,1411 @@ BOOL wxOSX_performDragOperation( id self, SEL _cmd, id <NSDraggingInfo> sender )
     return impl->performDragOperation(sender, self, _cmd) ? YES:NO ;
 }
 
+namespace {
+
+   wxAccessible *findAccessible( id view )
+   {
+      wxWidgetCocoaImpl* impl;
+      wxWindow* win;
+      wxAccessible *accessible;
+
+      if ((impl =
+           (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( view )) &&
+          (win = impl->GetWXPeer()) &&
+          (accessible = win->GetAccessible()))
+         return accessible;
+
+      return NULL;
+   }
+
+   id GetUIElement
+   (wxAccessible &accessible, int childID = wxACC_SELF,
+    wxAccessible *pChild = NULL)
+   {
+      if (pChild)
+         return pChild->GetWindow()->GetPeer()->GetWXWidget();
+      else
+         return
+         [wxAccessibilityChild accessibilityChildWithAccessible: &accessible
+                                                      andNumber: childID];
+   }
+
+   struct wxNSAccessibilityAttribute
+   {
+      explicit
+      wxNSAccessibilityAttribute(NSString *name_, bool dummy = false);
+
+      struct Hash
+      {
+         size_t operator()( const void* k ) const
+         {
+            return
+               [static_cast<const wxNSAccessibilityAttribute*>(k)->name hash];
+         }
+      };
+
+      struct Equal
+      {
+         bool operator()( const void* a, const void* b ) const
+         {
+            return
+               [static_cast<const wxNSAccessibilityAttribute*>(a)->name
+                isEqual:
+                static_cast<const wxNSAccessibilityAttribute*>(b)->name];
+         }
+      };
+
+      void RaiseException(id element, id value = nil) const
+      {
+         NSAccessibilityRaiseBadArgumentException(element, name, value);
+      }
+
+      virtual bool IsPresent
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual bool IsSettable
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual id Get
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         RaiseException(element);
+         return nil;
+      }
+
+      virtual void Set
+         (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         RaiseException(element, value);
+      }
+
+      NSString *const name;
+   };
+
+   WX_DECLARE_HASH_SET(
+      wxNSAccessibilityAttribute*,
+      wxNSAccessibilityAttribute::Hash,
+      wxNSAccessibilityAttribute::Equal,
+      AllAttributes
+   );
+
+   AllAttributes sAllAttributes;
+
+   wxNSAccessibilityAttribute::wxNSAccessibilityAttribute
+      (NSString *name_, bool dummy)
+   : name (name_)
+   {
+      if (!dummy)
+         sAllAttributes.insert(this);
+   }
+
+   const wxNSAccessibilityAttribute *findAttribute(id element, NSString *name)
+   {
+      wxNSAccessibilityAttribute attr(name, true);
+      AllAttributes::const_iterator it = sAllAttributes.find(&attr);
+      if (it != sAllAttributes.end())
+         return *it;
+      return NULL;
+   }
+
+   NSArray *findAttributeNames
+   ( id self, wxAccessible &accessible, int childId,
+    NSArray *otherAttributes )
+   {
+      NSMutableArray *result =
+      otherAttributes
+      ? [NSMutableArray arrayWithArray: otherAttributes]
+      : [NSMutableArray arrayWithCapacity: sAllAttributes.size()];
+      AllAttributes::const_iterator it = sAllAttributes.begin(),
+      end = sAllAttributes.end();
+      for (; it != end; ++it)
+      {
+         const wxNSAccessibilityAttribute &attribute = **it;
+         if (attribute.IsPresent(self, accessible, childId)) {
+            NSString *name = attribute.name;
+            if (otherAttributes && [otherAttributes containsObject: name])
+               // don't duplicate
+               continue;
+            [result addObject: name];
+         }
+      }
+      return result;
+   }
+
+   // Useful, still abstract, subclass of wxNSAccessibilityAttribute
+   // helps to implement other parts of the protocol that query only the
+   // size or a sub-range of the arrays.
+   struct wxNSAccessibilityArrayAttribute : wxNSAccessibilityAttribute
+   {
+      explicit
+      wxNSAccessibilityArrayAttribute(NSString *name)
+      : wxNSAccessibilityAttribute(name)
+      {}
+
+      virtual unsigned GetCount
+      (id element, wxAccessible &accessible, int childID) const = 0;
+
+      virtual id GetArrayElement
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index) const = 0;
+
+      NSUInteger IndexOfValue
+      (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         unsigned count = GetCount(element, accessible, childID);
+         for (unsigned index = 0; index < count; ++index)
+         {
+            id arrayElement =
+            GetArrayElement(element, accessible, childID, index);
+            if ([value isEqual: arrayElement])
+               return index;
+         }
+         return NSNotFound;
+      }
+
+      id GetValues
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index, unsigned maxCount) const
+      {
+         if (maxCount == 0)
+            return [NSArray array];
+
+         NSMutableArray *result =
+         [NSMutableArray arrayWithCapacity: (NSUInteger)maxCount];
+
+         unsigned limit = index + maxCount;
+         while (index < limit)
+         {
+            id arrayElement =
+            GetArrayElement(element, accessible, childID, index);
+            if (arrayElement)
+               [result addObject: arrayElement];
+            ++index;
+         }
+         return result;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         unsigned count = GetCount(element, accessible, childID);
+         return GetValues(element, accessible, childID, 0, count);
+      }
+   };
+
+   struct wxNAccessibilityStringAttribute : wxNSAccessibilityAttribute
+   {
+      typedef wxAccStatus (wxAccessible::*PMF)(int, wxString*);
+
+      wxNAccessibilityStringAttribute(NSString *name_, PMF pmf_)
+      : wxNSAccessibilityAttribute(name_)
+      , pmf(pmf_)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxString str;
+         return (wxACC_OK == (accessible.*pmf)(childID, &str));
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxString result;
+         if (wxACC_OK == (accessible.*pmf)(childID, &result))
+            return wxNSStringWithWxString(result);
+         else
+            return @"";
+      }
+
+      const PMF pmf;
+   };
+
+   template <
+      unsigned long StateFlag, bool StateFlagState,
+      unsigned long SettableFlag, bool SettableFlagState,
+      wxAccSelectionFlags SelectFlag
+   > struct wxNSAccessibilityStateAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityStateAttribute(NSString *name)
+      : wxNSAccessibilityAttribute(name)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id Get
+      (id, wxAccessible &accessible, int childID) const
+      {
+         BOOL result = NO;
+         long state = 0;
+         wxAccStatus status = accessible.GetState(childID, &state);
+         if (wxACC_OK == status &&
+             StateFlagState == !!(state & StateFlag))
+            result = YES;
+         return [NSNumber numberWithBool: result];
+      }
+
+      virtual bool IsSettable
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         long state = 0;
+         wxAccStatus status = accessible.GetState(childID, &state);
+         return
+         (wxACC_OK == status &&
+          SettableFlagState == !!(state & SettableFlag));
+      }
+
+      virtual void Set
+      (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         wxAccStatus status = accessible.Select(childID, SelectFlag);
+         WXUNUSED(status);
+      }
+   };
+   
+   // To do: for each of these attributes that is important, make a static
+   // object of a subclass of wxNSAccessibilityAttribute that gets and sets it.
+
+   /* Standard attributes
+    */
+
+   struct wxNSAccessibilityRoleAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityRoleAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityRoleAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         // Standard NSAccessibility roles that did not obviously correspond
+         // to any of the wxROLE constants
+         /*
+          NSAccessibilityTextAreaRole;
+          NSAccessibilityScrollAreaRole;
+          NSAccessibilityRadioGroupRole;
+          NSAccessibilityBusyIndicatorRole;
+          NSAccessibilityDrawerRole;
+          NSAccessibilitySystemWideRole;
+          NSAccessibilityBrowserRole;
+          NSAccessibilitySplitGroupRole;
+          NSAccessibilityColorWellRole;
+          NSAccessibilityMatteRole;
+          NSAccessibilityRulerRole;
+          NSAccessibilityRulerMarkerRole;
+          NSAccessibilityRelevanceIndicatorRole;
+          NSAccessibilityLevelIndicatorRole;
+
+          NSAccessibilityLayoutItemRole;
+
+          NSAccessibilityGridRole;
+          */
+
+         wxAccRole role;
+         if (wxACC_OK == accessible.GetRole(childID, &role)) switch (role)
+         {
+            case wxROLE_SYSTEM_ANIMATION:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_APPLICATION:
+               return NSAccessibilityApplicationRole;
+
+            case wxROLE_SYSTEM_BORDER:
+               return NSAccessibilityGrowAreaRole; // ??
+
+            case wxROLE_SYSTEM_BUTTONDROPDOWN:
+            case wxROLE_SYSTEM_BUTTONDROPDOWNGRID:
+               return NSAccessibilityPopUpButtonRole;
+
+            case wxROLE_SYSTEM_BUTTONMENU:
+               return NSAccessibilityMenuButtonRole;
+
+            case wxROLE_SYSTEM_CELL:
+               return NSAccessibilityCellRole;
+
+            case wxROLE_SYSTEM_CHART:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_CHECKBUTTON:
+               return NSAccessibilityCheckBoxRole;
+
+            case wxROLE_SYSTEM_COLUMN:
+            case wxROLE_SYSTEM_COLUMNHEADER:
+               return NSAccessibilityColumnRole;
+
+            case wxROLE_SYSTEM_COMBOBOX:
+               return NSAccessibilityComboBoxRole;
+
+            case wxROLE_SYSTEM_DIAGRAM:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_DIAL:
+               return NSAccessibilitySliderRole; //??
+
+            case wxROLE_SYSTEM_DIALOG:
+               return NSAccessibilitySheetRole;
+
+            case wxROLE_SYSTEM_DOCUMENT:
+               return NSAccessibilityTextAreaRole; // ??
+
+            case wxROLE_SYSTEM_DROPLIST:
+               return NSAccessibilityMenuRole; // ??
+
+            case wxROLE_SYSTEM_GRAPHIC:
+               return NSAccessibilityImageRole;
+
+            case wxROLE_SYSTEM_GRIP:
+               return NSAccessibilityHandleRole;
+
+            case wxROLE_SYSTEM_GROUPING:
+               return NSAccessibilityGroupRole;
+
+            case wxROLE_SYSTEM_HELPBALLOON:
+               return NSAccessibilityHelpTagRole;
+
+            case wxROLE_SYSTEM_HOTKEYFIELD:
+               return NSAccessibilityTextFieldRole; // ??
+
+            case wxROLE_SYSTEM_INDICATOR:
+               return NSAccessibilityValueIndicatorRole;
+
+            case wxROLE_SYSTEM_LINK:
+               return NSAccessibilityLinkRole;
+
+            case wxROLE_SYSTEM_LIST:
+               return NSAccessibilityListRole;
+
+            case wxROLE_SYSTEM_LISTITEM:
+               return NSAccessibilityMenuItemRole; // ??
+
+            case wxROLE_SYSTEM_MENUBAR:
+               return NSAccessibilityMenuBarRole;
+
+            case wxROLE_SYSTEM_MENUITEM:
+               return NSAccessibilityMenuItemRole;
+
+            case wxROLE_SYSTEM_MENUPOPUP:
+               return NSAccessibilityMenuRole;
+
+            case wxROLE_SYSTEM_OUTLINE:
+               return NSAccessibilityOutlineRole;
+
+            case wxROLE_SYSTEM_OUTLINEITEM:
+               return NSAccessibilityDisclosureTriangleRole; // ??
+
+            case wxROLE_SYSTEM_PAGETAB:
+               return NSAccessibilityButtonRole; // ???
+
+            case wxROLE_SYSTEM_PAGETABLIST:
+               return NSAccessibilityTabGroupRole; // ??
+
+            case wxROLE_SYSTEM_PANE:
+               return NSAccessibilityLayoutAreaRole; // ??
+
+            case wxROLE_SYSTEM_PROGRESSBAR:
+               return NSAccessibilityProgressIndicatorRole;
+
+            case wxROLE_SYSTEM_PROPERTYPAGE:
+               return NSAccessibilitySheetRole; // ??
+
+            case wxROLE_SYSTEM_PUSHBUTTON:
+               return NSAccessibilityButtonRole;
+
+            case wxROLE_SYSTEM_RADIOBUTTON:
+               return NSAccessibilityRadioButtonRole;
+
+            case wxROLE_SYSTEM_ROWHEADER:
+            case wxROLE_SYSTEM_ROW:
+               return NSAccessibilityRowRole;
+
+            case wxROLE_SYSTEM_SCROLLBAR:
+               return NSAccessibilityScrollBarRole;
+
+            case wxROLE_SYSTEM_SEPARATOR:
+               return NSAccessibilitySplitterRole; // ??
+
+            case wxROLE_SYSTEM_SLIDER:
+               return NSAccessibilitySliderRole;
+
+            case wxROLE_SYSTEM_SPINBUTTON:
+               return NSAccessibilityIncrementorRole;
+
+            case wxROLE_SYSTEM_STATICTEXT:
+               return NSAccessibilityStaticTextRole;
+
+            case wxROLE_SYSTEM_STATUSBAR:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_TABLE:
+               return NSAccessibilityTableRole;
+
+            case wxROLE_SYSTEM_TEXT:
+               return NSAccessibilityTextFieldRole;
+
+            case wxROLE_SYSTEM_TITLEBAR:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_TOOLBAR:
+               return NSAccessibilityToolbarRole;
+
+            case wxROLE_SYSTEM_TOOLTIP:
+               return NSAccessibilityHelpTagRole; // ??
+
+            case wxROLE_SYSTEM_WHITESPACE:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_WINDOW:
+               return NSAccessibilityWindowRole;
+
+               // wxROLE constants that did not correspond to anything obvious
+               // in the list of standard NSAccessibility roles
+            case wxROLE_NONE:
+            case wxROLE_SYSTEM_ALERT:
+            case wxROLE_SYSTEM_CARET:
+            case wxROLE_SYSTEM_CHARACTER:
+            case wxROLE_SYSTEM_CLIENT:
+            case wxROLE_SYSTEM_CLOCK:
+            case wxROLE_SYSTEM_CURSOR:
+            case wxROLE_SYSTEM_EQUATION:
+            case wxROLE_SYSTEM_SOUND:
+            default:
+               return NSAccessibilityUnknownRole;
+         }
+         else
+            return NSAccessibilityUnknownRole;
+      }
+   } swxNSAccessibilityRoleAttribute;
+
+   struct wxNSAccessibilitySubroleAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilitySubroleAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilitySubroleAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         // Improve this
+         return NSAccessibilityUnknownSubrole;
+      }
+   } swxNSAccessibilitySubroleAttribute;
+   
+   struct wxNSAccessibilityRoleDescriptionAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityRoleDescriptionAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityRoleDescriptionAttribute) {}
+      
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+      
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         id role =
+         swxNSAccessibilityRoleAttribute.Get(element, accessible, childID);
+         id subRole =
+         swxNSAccessibilitySubroleAttribute.Get(element, accessible, childID);
+         NSString *result =
+         NSAccessibilityRoleDescription((NSString*)role, (NSString*)subRole);
+         return result;
+      }
+   } swxNSAccessibilityRoleDescriptionAttribute;
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityHelpAttribute
+      (NSAccessibilityHelpAttribute, &wxAccessible::GetHelpText);
+
+   // Not different from value -- is that right?
+   wxNAccessibilityStringAttribute sxwNSAccessibilityValueAttribute
+      (NSAccessibilityValueAttribute, &wxAccessible::GetValue);
+
+#if 0
+   NSAccessibilityMinValueAttribute;		//(id)         - element's min value
+   NSAccessibilityMaxValueAttribute;		//(id)         - element's max value
+#endif
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_UNAVAILABLE, false,
+      0, true, wxACC_SEL_NONE // not settable
+   > swxNSAccessibilityEnabledAttribute(NSAccessibilityEnabledAttribute);
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_FOCUSED, true,
+      wxACC_STATE_SYSTEM_FOCUSABLE, true,
+      wxACC_SEL_TAKEFOCUS
+   > swxNSAccessibilityFocusedAttribute(NSAccessibilityFocusedAttribute);
+
+   struct wxNSAccessibilityParentAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityParentAttribute()
+      : wxNSAccessibilityAttribute(NSAccessibilityParentAttribute)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return nil != Get(element, accessible, childID);
+      }
+
+      virtual id Get
+      (id, wxAccessible &accessible, int childID) const
+      {
+         // I'm not using wxAccessible::GetParent() because the default
+         // implementation has the undesirable side effect of creating
+         // wxAccessible objects for windows that did not already have them.
+
+         wxWindow *window = accessible.GetWindow();
+
+         if (childID != wxACC_SELF)
+            // report parent of non-window accessible element
+            return window->GetPeer()->GetWXWidget();
+
+         // Report direct parent window if that defines a wxAccessible
+         wxWindow *parent = window->GetParent();
+         if (parent && parent->GetAccessible())
+         {
+            NSObject *widget = parent->GetPeer()->GetWXWidget();
+            return widget;
+         }
+
+         // Cause defaulting to the framework's definition of parent
+         return nil;
+      }
+   } swxNSAccessibilityParentAttribute;
+
+   //(NSArray *)  - elements you contain
+   struct wxNSAccessibilityChildrenAttributeBase : wxNSAccessibilityArrayAttribute
+   {
+      wxNSAccessibilityChildrenAttributeBase(NSString *name_)
+      : wxNSAccessibilityArrayAttribute(name_)
+      {}
+
+      virtual bool Condition
+         (wxAccessible &accessible, int childID,
+          wxAccessible *pChild) const = 0;
+
+      virtual bool IsPresent
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual unsigned GetCount
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         if (childID != 0)
+            return 0;
+
+         int childCount;
+         wxAccStatus status = accessible.GetChildCount(&childCount);
+         if (status != wxACC_OK || childCount <= 0)
+            return 0;
+         else
+            return childCount;
+      }
+
+      virtual id GetArrayElement
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index) const
+      {
+         if (childID != 0)
+            return nil;
+
+         wxAccessible *child = NULL;
+         wxAccStatus status = accessible.GetChild(index + 1, &child);
+         if (status != wxACC_OK)
+            return nil;
+
+         if (!Condition(accessible, index + 1, child))
+            return nil;
+
+         return GetUIElement(accessible, index + 1, child);
+      }
+   };
+
+   struct wxNSAccessibilityChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilityChildrenAttribute
+         (NSString *attr = NSAccessibilityChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition(wxAccessible &, int, wxAccessible *) const
+      {
+         return true;
+      }
+
+   } swxNSAccessibilityChildrenAttribute;
+
+   struct wxNSAccessibilityWindowAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityWindowAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityWindowAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxWindow *pWindow = accessible.GetWindow(), *pParent;
+         while (!dynamic_cast<wxNonOwnedWindow*>(pWindow) &&
+            NULL != (pParent = pWindow->GetParent()))
+            pWindow = pParent;
+         NSObject *widget = pWindow->GetPeer()->GetWXWidget();
+         return widget;
+      }
+   } swxNSAccessibilityWindowAttribute;
+
+   struct wxNSAccessibilityTopLevelUIAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityTopLevelUIAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityTopLevelUIElementAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return element;
+         /*
+         id prevElement = element, newElement;
+         do try {
+            newElement =
+               [element accessibilityAttributeValue: NSAccessibilityParentAttribute];
+         }
+         catch(...) {
+            return prevElement;
+         }
+         while (newElement != NULL &&
+                (prevElement = element, element = newElement));
+         return element;
+          */
+      }
+   } swxNSAccessibilityTopLevelUIAttribute;
+   
+   struct wxNSAccessibilitySelectedChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilitySelectedChildrenAttribute
+         (NSString *attr = NSAccessibilitySelectedChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition
+      (wxAccessible &accessible, int childID,
+       wxAccessible *pChild) const
+      {
+         wxAccStatus status;
+         long state = 0;
+         if (pChild)
+            status = pChild->GetState(wxACC_SELF, &state);
+         else
+            status = accessible.GetState(childID, &state);
+
+         return (status == wxACC_OK &&
+                 0 != (state & wxACC_STATE_SYSTEM_SELECTED));
+      }
+   } swxNSAccessibilitySelectedChildrenAttribute;
+
+   struct wxNSAccessibilityVisibleChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilityVisibleChildrenAttribute
+         (NSString *attr = NSAccessibilityVisibleChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition
+      (wxAccessible &accessible, int childID,
+       wxAccessible *pChild) const
+      {
+         wxAccStatus status;
+         long state = 0;
+         if (pChild)
+            status = pChild->GetState(wxACC_SELF, &state);
+         else
+            status = accessible.GetState(childID, &state);
+
+         return (status == wxACC_OK &&
+                 0 == (state & wxACC_STATE_SYSTEM_INVISIBLE));
+      }
+   } swxNSAccessibilityVisibleChildrenAttribute;
+
+   struct wxNSAccessibilityPositionAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityPositionAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityPositionAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         return (wxACC_OK == accessible.GetLocation(rect, childID));
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         NSPoint point = { 0, 0 };
+         if (wxACC_OK == accessible.GetLocation(rect, childID))
+         {
+            int height;
+            ::wxDisplaySize(NULL, &height);
+            point.x = rect.x, point.y = height - rect.y - rect.height;
+         }
+         return [NSValue valueWithBytes: &point objCType: @encode(NSPoint)];
+      }
+   } swxNSAccessibilityPositionAttribute;
+
+   struct wxNSAccessibilitySizeAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilitySizeAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilitySizeAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         return (wxACC_OK == accessible.GetLocation(rect, childID));
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         NSSize size = { 0, 0 };
+         if (wxACC_OK == accessible.GetLocation(rect, childID))
+            size.width = rect.width, size.height = rect.height;
+         return [NSValue valueWithBytes: &size objCType: @encode(NSSize)];
+      }
+   } swxNSAccessibilitySizeAttribute;
+
+   // Make "contents" no different from "children" -- is that right?
+   wxNSAccessibilityChildrenAttribute
+      swxNSAccessibilityContentsAttribute(NSAccessibilityContentsAttribute);
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityTitleAttribute
+      (NSAccessibilityTitleAttribute, &wxAccessible::GetName);
+   wxNAccessibilityStringAttribute sxwNSAccessibilityDescriptionAttribute
+      (NSAccessibilityDescriptionAttribute, &wxAccessible::GetDescription);
+
+#if 0
+   NSAccessibilityShownMenuAttribute		//(id)         - menu being displayed
+   ;
+#endif
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityValueDescriptionAttribute
+      (NSAccessibilityValueDescriptionAttribute, &wxAccessible::GetValue);
+
+#if 0
+   /* Misc attributes
+    */
+   NSAccessibilityPreviousContentsAttribute;	//(NSArray *)  - main elements
+   NSAccessibilityNextContentsAttribute;	//(NSArray *)  - main elements
+   NSAccessibilityHeaderAttribute;		//(id)         - UIElement for header.
+   NSAccessibilityEditedAttribute;		//(NSNumber *) - (boolValue) is it dirty?
+   NSAccessibilityTabsAttribute;		//(NSArray *)  - UIElements for tabs
+   NSAccessibilityHorizontalScrollBarAttribute;//(id)       - UIElement for the horizontal scroller
+   NSAccessibilityVerticalScrollBarAttribute;//(id)         - UIElement for the vertical scroller
+   NSAccessibilityOverflowButtonAttribute;	//(id)         - UIElement for overflow
+   NSAccessibilityIncrementButtonAttribute;	//(id)         - UIElement for increment
+   NSAccessibilityDecrementButtonAttribute;	//(id)         - UIElement for decrement
+   NSAccessibilityFilenameAttribute;		//(NSString *) - filename
+#endif
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_EXPANDED, true,
+      0, true, wxACC_SEL_NONE // not settable
+   > swxNSAccessibilityExpandedAttribute(NSAccessibilityExpandedAttribute);
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_SELECTED, true,
+      wxACC_STATE_SYSTEM_SELECTABLE, true,
+      wxACC_SEL_TAKESELECTION
+   > swxNSAccessibilitySelectedAttribute(NSAccessibilitySelectedAttribute);
+
+#if 0
+   NSAccessibilitySplittersAttribute;	//(NSArray *)  - UIElements for splitters
+   NSAccessibilityDocumentAttribute;		//(NSString *) - url as string - for open document
+   NSAccessibilityURLAttribute		//(NSURL *)    - url
+   ;
+   NSAccessibilityIndexAttribute		//(NSNumber *)  - (intValue)
+   ;
+
+   NSAccessibilityRowCountAttribute		//(NSNumber *)  - (intValue) number of rows
+   ;
+   NSAccessibilityColumnCountAttribute	//(NSNumber *)  - (intValue) number of columns
+   ;
+   NSAccessibilityOrderedByRowAttribute	//(NSNumber *)  - (boolValue) is ordered by row?
+   ;
+
+   NSAccessibilityWarningValueAttribute	//(id)  - warning value of a level indicator, typically a number
+   ;
+   NSAccessibilityCriticalValueAttribute	//(id)  - critical value of a level indicator, typically a number
+   ;
+   NSAccessibilityPlaceholderValueAttribute	//(NSString *)  - placeholder value of a control such as a text field
+   ;
+
+   /* Linkage attributes
+    */
+   NSAccessibilityTitleUIElementAttribute;		//(id)	      - UIElement for the title
+   NSAccessibilityServesAsTitleForUIElementsAttribute//(NSArray *) - UIElements this titles
+   ;
+   NSAccessibilityLinkedUIElementsAttribute		//(NSArray *) - corresponding UIElements
+   ;
+
+
+   /* Text-specific attributes
+    */
+   NSAccessibilitySelectedTextAttribute;		//(NSString *) - selected text
+   NSAccessibilitySelectedTextRangeAttribute;	//(NSValue *)  - (rangeValue) range of selected text
+   NSAccessibilityNumberOfCharactersAttribute	//(NSNumber *) - number of characters
+   ;
+   NSAccessibilityVisibleCharacterRangeAttribute	//(NSValue *)  - (rangeValue) range of visible text
+   ;
+   NSAccessibilitySharedTextUIElementsAttribute	//(NSArray *)  - text views sharing text
+   ;
+   NSAccessibilitySharedCharacterRangeAttribute	//(NSValue *)  - (rangeValue) part of shared text in this view
+   ;
+   NSAccessibilityInsertionPointLineNumberAttribute	//(NSNumber *) - line# containing caret
+   ;
+   NSAccessibilitySelectedTextRangesAttribute	//(NSArray *) - array of NSValue (rangeValue) ranges of selected text
+   ;
+
+
+   /* Parameterized text-specific attributes
+    */
+   NSAccessibilityLineForIndexParameterizedAttribute		//(NSNumber *) - line# for char index; param:(NSNumber *)
+   ;
+   NSAccessibilityRangeForLineParameterizedAttribute		//(NSValue *)  - (rangeValue) range of line; param:(NSNumber *)
+   ;
+   NSAccessibilityStringForRangeParameterizedAttribute	//(NSString *) - substring; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityRangeForPositionParameterizedAttribute	//(NSValue *)  - (rangeValue) composed char range; param:(NSValue * - pointValue)
+   ;
+   NSAccessibilityRangeForIndexParameterizedAttribute	//(NSValue *)  - (rangeValue) composed char range; param:(NSNumber *)
+   ;
+   NSAccessibilityBoundsForRangeParameterizedAttribute	//(NSValue *)  - (rectValue) bounds of text; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityRTFForRangeParameterizedAttribute		//(NSData *)   - rtf for text; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityStyleRangeForIndexParameterizedAttribute	//(NSValue *)  - (rangeValue) extent of style run; param:(NSNumber *)
+   ;
+   NSAccessibilityAttributedStringForRangeParameterizedAttribute //(NSAttributedString *) - does _not_ use attributes from Appkit/AttributedString.h
+   ;
+
+
+   /* Text attributed string attributes and constants
+    */
+   NSAccessibilityFontTextAttribute			//(NSDictionary *)  - NSAccessibilityFontXXXKey's
+   ;
+   NSAccessibilityForegroundColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityBackgroundColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityUnderlineColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityStrikethroughColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityUnderlineTextAttribute		//(NSNumber *)	    - underline style
+   ;
+   NSAccessibilitySuperscriptTextAttribute		//(NSNumber *)	    - superscript>0, subscript<0
+   ;
+   NSAccessibilityStrikethroughTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+   NSAccessibilityShadowTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+   NSAccessibilityAttachmentTextAttribute		//id - corresponding element
+   ;
+   NSAccessibilityLinkTextAttribute			//id - corresponding element
+   ;
+   NSAccessibilityMisspelledTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+
+   NSAccessibilityFontNameKey	// required
+   ;
+   NSAccessibilityFontFamilyKey	// optional
+   ;
+   NSAccessibilityVisibleNameKey	// optional
+   ;
+   NSAccessibilityFontSizeKey	// required
+   ;
+
+
+   /* Window-specific attributes
+    */
+   NSAccessibilityMainAttribute;		//(NSNumber *) - (boolValue) is it the main window?
+   NSAccessibilityMinimizedAttribute;	//(NSNumber *) - (boolValue) is window minimized?
+   NSAccessibilityCloseButtonAttribute;	//(id) - UIElement for close box (or nil)
+   NSAccessibilityZoomButtonAttribute;	//(id) - UIElement for zoom box (or nil)
+   NSAccessibilityMinimizeButtonAttribute;	//(id) - UIElement for miniaturize box (or nil)
+   NSAccessibilityToolbarButtonAttribute;	//(id) - UIElement for toolbar box (or nil)
+   NSAccessibilityProxyAttribute;		//(id) - UIElement for title's icon (or nil)
+   NSAccessibilityGrowAreaAttribute;		//(id) - UIElement for grow box (or nil)
+   NSAccessibilityModalAttribute		//(NSNumber *) - (boolValue) is the window modal
+   ;
+   NSAccessibilityDefaultButtonAttribute	//(id) - UIElement for default button
+   ;
+   NSAccessibilityCancelButtonAttribute	//(id) - UIElement for cancel button
+   ;
+
+   /* Application-specific attributes
+    */
+   NSAccessibilityMenuBarAttribute;		//(id)         - UIElement for the menu bar
+   NSAccessibilityWindowsAttribute;		//(NSArray *)  - UIElements for the windows
+   NSAccessibilityFrontmostAttribute;	//(NSNumber *) - (boolValue) is the app active?
+   NSAccessibilityHiddenAttribute;		//(NSNumber *) - (boolValue) is the app hidden?
+   NSAccessibilityMainWindowAttribute;	//(id)         - UIElement for the main window.
+   NSAccessibilityFocusedWindowAttribute;	//(id)         - UIElement for the key window.
+   NSAccessibilityFocusedUIElementAttribute;	//(id)         - Currently focused UIElement.
+
+   NSAccessibilityOrientationAttribute;	//(NSString *) - NSAccessibilityXXXOrientationValue
+   NSAccessibilityVerticalOrientationValue;
+   NSAccessibilityHorizontalOrientationValue;
+   NSAccessibilityUnknownOrientationValue	;
+
+   NSAccessibilityColumnTitlesAttribute;	//(NSArray *)  - UIElements for titles
+
+   NSAccessibilitySearchButtonAttribute	//(id)         - UIElement for search field search btn
+   ;
+   NSAccessibilitySearchMenuAttribute	//(id)         - UIElement for search field menu
+   ;
+   NSAccessibilityClearButtonAttribute	//(id)         - UIElement for search field clear btn
+   ;
+
+
+   /* Table/outline view attributes
+    */
+   NSAccessibilityRowsAttribute;		//(NSArray *)  - UIElements for rows
+   NSAccessibilityVisibleRowsAttribute;	//(NSArray *)  - UIElements for visible rows
+   NSAccessibilitySelectedRowsAttribute;	//(NSArray *)  - UIElements for selected rows
+   NSAccessibilityColumnsAttribute;		//(NSArray *)  - UIElements for columns
+   NSAccessibilityVisibleColumnsAttribute;	//(NSArray *)  - UIElements for visible columns
+   NSAccessibilitySelectedColumnsAttribute;	//(NSArray *)  - UIElements for selected columns
+   NSAccessibilitySortDirectionAttribute	//(NSString *) - see sort direction values below
+   ;
+
+   /* Cell-based table attributes
+    */
+   NSAccessibilitySelectedCellsAttribute ;	//(NSArray *)  - UIElements for selected cells
+   NSAccessibilityVisibleCellsAttribute ;	//(NSArray *)  - UIElements for visible cells
+   NSAccessibilityRowHeaderUIElementsAttribute ;	//(NSArray *)  - UIElements for row headers
+   NSAccessibilityColumnHeaderUIElementsAttribute ;	//(NSArray *)  - UIElements for column headers
+
+   /* Cell-based table parameterized attributes.  The parameter for this attribute is an NSArray containing two NSNumbers, the first NSNumber specifies the column index, the second NSNumber specifies the row index.
+    */
+   NSAccessibilityCellForColumnAndRowParameterizedAttribute ;  // (id) - UIElement for cell at specified row and column
+
+   /* Cell attributes.  The index range contains both the starting index, and the index span in a table.
+    */
+   NSAccessibilityRowIndexRangeAttribute ;	//(NSValue *)  - (rangeValue) location and row span
+   NSAccessibilityColumnIndexRangeAttribute ;   //(NSValue *)  - (rangeValue) location and column span
+
+   /* Layout area attributes
+    */
+   NSAccessibilityHorizontalUnitsAttribute ;   //(NSString *) - see ruler unit values below
+   NSAccessibilityVerticalUnitsAttribute ;	    //(NSString *) - see ruler unit values below
+   NSAccessibilityHorizontalUnitDescriptionAttribute ; //(NSString *)
+   NSAccessibilityVerticalUnitDescriptionAttribute ;    //(NSString *)
+
+   /* Layout area parameterized attributes
+    */
+   NSAccessibilityLayoutPointForScreenPointParameterizedAttribute ; //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
+   NSAccessibilityLayoutSizeForScreenSizeParameterizedAttribute ; //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
+   NSAccessibilityScreenPointForLayoutPointParameterizedAttribute ; //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
+   NSAccessibilityScreenSizeForLayoutSizeParameterizedAttribute ; //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
+
+   /* Layout item attributes
+    */
+   NSAccessibilityHandlesAttribute ; //(NSArray *)  - UIElements for handles
+
+   /* Sort direction values
+    */
+   NSAccessibilityAscendingSortDirectionValue	;
+   NSAccessibilityDescendingSortDirectionValue	;
+   NSAccessibilityUnknownSortDirectionValue		;
+
+   /* Outline attributes
+    */
+   NSAccessibilityDisclosingAttribute;	//(NSNumber *) - (boolValue) is diclosing rows?
+   NSAccessibilityDisclosedRowsAttribute;	//(NSArray *)  - UIElements for disclosed rows
+   NSAccessibilityDisclosedByRowAttribute;	//(id)         - UIElement for disclosing row
+   NSAccessibilityDisclosureLevelAttribute	//(NSNumber *) - indentation level
+   ;
+
+   /* Slider attributes
+    */
+   NSAccessibilityAllowedValuesAttribute	//(NSArray *) - array of allowed values
+   ;
+   NSAccessibilityLabelUIElementsAttribute	//(NSArray *) - array of label UIElements
+   ;
+   NSAccessibilityLabelValueAttribute	//(NSNumber *) - value of a label UIElement
+   ;
+
+   /* Matte attributes
+    */
+   NSAccessibilityMatteHoleAttribute		//(NSValue *) - (rect value) bounds of matte hole in screen coords
+   ;
+   NSAccessibilityMatteContentUIElementAttribute //(id) - UIElement clipped by the matte
+   ;
+
+   /* Ruler view attributes
+    */
+   NSAccessibilityMarkerUIElementsAttribute		//(NSArray *)
+   ;
+   NSAccessibilityMarkerValuesAttribute		//
+   ;
+   NSAccessibilityMarkerGroupUIElementAttribute	//(id)
+   ;
+   NSAccessibilityUnitsAttribute			//(NSString *) - see ruler unit values below
+   ;
+   NSAccessibilityUnitDescriptionAttribute		//(NSString *)
+   ;
+   NSAccessibilityMarkerTypeAttribute		//(NSString *) - see ruler marker type values below
+   ;
+   NSAccessibilityMarkerTypeDescriptionAttribute	//(NSString *)
+   ;
+
+   /* Deprecated
+    */
+   NSAccessibilityHorizontialUnitsAttribute ;
+   NSAccessibilityHorizontialUnitDescriptionAttribute ;
+#endif
+
+}
+
+NSArray *wxOSX_accessibilityAttributeNames( id self, SEL _cmd )
+{
+   // Pass-through first
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+
+   // Add more attributes
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+      return findAttributeNames( self, *accessible, wxACC_SELF, result );
+
+   return result;
+}
+
+id wxOSX_accessibilityAttributeValue( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+         return pAttribute->Get(self, *accessible, wxACC_SELF);
+   }
+
+   // Otherwise, pass-through
+   typedef id (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+BOOL wxOSX_accessibilityIsAttributeSettable( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+         return pAttribute->IsSettable(self, *accessible, wxACC_SELF);
+   }
+
+   // Otherwise, pass-through
+   typedef BOOL (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+void wxOSX_accessibilitySetValue_forAttribute( id self, SEL _cmd, id value, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         if (pAttribute->IsSettable(self, *accessible, wxACC_SELF))
+            pAttribute->Set(self, *accessible, wxACC_SELF, value);
+         return;
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef void (*Function)(id, SEL, id, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   superimpl(self, _cmd, value, attribute);
+}
+
+NSArray *wxOSX_accessibilityParameterizedAttributeNames( id self, SEL _cmd )
+{
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+   return result;
+}
+
+id wxOSX_accessibilityAttributeValue_forParameter
+   ( id self, SEL _cmd, NSString *attribute, id parameter )
+{
+   typedef id (*Function)(id, SEL, NSString*, id);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, attribute, parameter);
+   return result;
+}
+
+NSArray *wxOSX_accessibilityActionNames( id self, SEL _cmd )
+{
+#if 0
+   /* Actions
+    */
+NSAccessibilityPressAction;
+NSAccessibilityIncrementAction;
+NSAccessibilityDecrementAction;
+NSAccessibilityConfirmAction;
+NSAccessibilityPickAction;
+NSAccessibilityCancelAction;
+NSAccessibilityRaiseAction;
+NSAccessibilityShowMenuAction;
+NSAccessibilityDeleteAction;
+#endif
+
+   // This function produces an array of standard action string keys, which are
+   // not localized action descriptions.  So wxAccessible::GetDefaultAction()
+   // is not what we want.
+
+   // So in default of a better thing to do,
+   // we just give everything one press action, and only in case a default
+   // action is defined.
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+   {
+      wxString unused;
+      wxAccStatus status = pAccessible->GetDefaultAction(wxACC_SELF, &unused);
+      if (status == wxACC_OK)
+      {
+         return [NSArray arrayWithObject: NSAccessibilityPressAction];
+      }
+   }
+
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+   return result;
+}
+
+NSString *wxOSX_accessibilityActionDescription( id self, SEL _cmd, NSString *action )
+{
+   NSString *result = NSAccessibilityActionDescription(action);
+   if (result)
+      return result;
+
+   typedef NSString *(*Function)(id, SEL, NSString*);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   result = superimpl(self, _cmd, action);
+   return result;
+}
+
+void wxOSX_accessibilityPerformAction( id self, SEL _cmd, NSString *action )
+{
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+   {
+      wxAccStatus status = pAccessible->DoDefaultAction(wxACC_SELF);
+      if (status == wxACC_OK)
+         return;
+   }
+
+   typedef void (*Function)(id, SEL, NSString*);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   superimpl(self, _cmd, action);
+}
+
+BOOL wxOSX_accessibilityIsIgnored( id self, SEL _cmd )
+{
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+      return NO;
+
+   typedef BOOL (*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd);
+   return result;
+}
+
+id wxOSX_accessibilityHitTest( id self, SEL _cmd, NSPoint point )
+{
+   typedef id (*Function)(id, SEL, NSPoint);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, point);
+   return result;
+}
+
+id wxOSX_accessibilityFocusedUIElement( id self, SEL _cmd )
+{
+   typedef id (*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd);
+   return result;
+}
+
+NSUInteger wxOSX_accessibilityIndexOfChild( id self, SEL _cmd, id child )
+{
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      return swxNSAccessibilityChildrenAttribute
+         .IndexOfValue(self, *accessible, wxACC_SELF, child);
+   }
+
+   typedef NSUInteger (*Function)(id, SEL, id);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSUInteger result = superimpl(self, _cmd, child);
+   return result;
+}
+
+NSUInteger wxOSX_accessibilityArrayAttributeCount( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+            dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+         if (pArrayAttribute)
+         {
+            return pArrayAttribute->GetCount(self, *accessible, wxACC_SELF);
+         }
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef NSUInteger (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSUInteger result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+NSArray *wxOSX_accessibilityArrayAttributeValues_index_maxCount
+   ( id self, SEL _cmd, NSString *attribute, NSUInteger index, NSUInteger maxCount )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+         dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+         if (pArrayAttribute)
+         {
+            return pArrayAttribute->GetValues
+               (self, *accessible, wxACC_SELF, index, maxCount);
+         }
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef NSArray *(*Function)(id, SEL, NSString *, NSUInteger, NSUInteger);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd, attribute, index, maxCount);
+   return result;
+}
+
+BOOL wxOSX_accessibilitySetOverrideValue_forAttribute( id self, SEL _cmd, NSString *attribute )
+{
+   typedef BOOL (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+
 #endif
 
+NSString* wxOSX_stringValue(id self, SEL _cmd)
+{
+   if ([[self superclass] instancesRespondToSelector: _cmd])
+   {
+      typedef NSString* (*Function)(id, SEL);
+      Function superimpl = (Function)
+         [[self superclass] instanceMethodForSelector:_cmd];
+      return superimpl(self, _cmd);
+   }
+   else
+      return @"";
+}
+
 void wxOSX_mouseEvent(NSView* self, SEL _cmd, NSEvent *event)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1771,6 +3192,435 @@ void wxWidgetCocoaImpl::controlTextDidChange()
 
 #endif
 
+@implementation wxAccessibilityChild
+- (id)initWithAccessible: (wxAccessible*) accessible_
+                  andNumber: (NSInteger) number_
+{
+   self = [super init];
+   accessible = accessible_;
+   number = number_;
+   return self;
+}
+
++ (id)accessibilityChildWithAccessible: (wxAccessible*)accessible_
+                             andNumber: (NSInteger)number_;
+{
+   return [
+      [[wxAccessibilityChild alloc]
+          initWithAccessible: accessible_ andNumber: number_]
+      autorelease
+   ];
+}
+
+- (NSString*)stringValue
+{
+   // For debugging
+   return @"";
+}
+
+- (BOOL)isEqual:(id)object
+{
+   if ([object isMemberOfClass: [wxAccessibilityChild class]])
+   {
+      wxAccessibilityChild *other = (wxAccessibilityChild*)object;
+      if (accessible == other->accessible && number == other->number)
+         return YES;
+   }
+   return NO;
+}
+
+// Implement the NSObject (NSAccessibility) informal protocol with appropriate
+// forwards to the wxAccessible object
+
+/* Attribute methods
+ */
+- (NSArray *)accessibilityAttributeNames
+{
+   return findAttributeNames( self, *accessible, number, NULL );
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+      return pAttribute->Get(self, *accessible, number);
+   return [super accessibilityAttributeValue: attribute];
+}
+
+- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+      return pAttribute->IsSettable(self, *accessible, number);
+   return [super accessibilityIsAttributeSettable: attribute];
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      if (pAttribute->IsSettable(self, *accessible, number))
+         pAttribute->Set(self, *accessible, number, value);
+      return;
+   }
+
+   [super accessibilitySetValue: value forAttribute: attribute];
+}
+
+/* Parameterized Attribute methods
+ */
+- (NSArray *)accessibilityParameterizedAttributeNames
+{
+   return [super accessibilityParameterizedAttributeNames];
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute forParameter:(id)parameter
+{
+   return [super accessibilityAttributeValue: attribute forParameter: parameter];
+}
+
+/* Acessibility action methods
+ */
+- (NSArray *)accessibilityActionNames
+{
+   // see comments in wxOSX_accessibilityActionNames
+   wxString unused;
+   wxAccStatus status = accessible->GetDefaultAction(number, &unused);
+   if (status == wxACC_OK)
+   {
+      return [NSArray arrayWithObject: NSAccessibilityPressAction];
+   }
+
+   if ([[self superclass] instancesRespondToSelector:
+        @selector(accessibilityActionNames)])
+      return [super accessibilityActionNames];
+   return [NSArray array];
+}
+
+- (NSString *)accessibilityActionDescription:(NSString *)action
+{
+   NSString *result = NSAccessibilityActionDescription(action);
+   if (result)
+      return result;
+
+   return [super accessibilityActionDescription: action];
+}
+
+- (void)accessibilityPerformAction:(NSString *)action
+{
+   wxAccStatus status = accessible->DoDefaultAction(number);
+   if (status == wxACC_OK)
+      return;
+
+   [super accessibilityPerformAction: action];
+}
+
+/* Return YES if the UIElement doesn't show up to the outside world - i.e. its parent should return the UIElement's children as its own - cutting the UIElement out. E.g. NSControls are ignored when they are single-celled.
+ */
+- (BOOL)accessibilityIsIgnored
+{
+   return NO;
+}
+
+/* Returns the deepest descendant of the UIElement hierarchy that contains the point. You can assume the point has already been determined to lie within the receiver. Override this method to do deeper hit testing within a UIElement - e.g. a NSMatrix would test its cells. The point is bottom-left relative screen coordinates.
+ */
+- (id)accessibilityHitTest:(NSPoint)point
+{
+   return [super accessibilityHitTest: point];
+}
+
+/* Returns the UI Element that has the focus. You can assume that the search for the focus has already been narrowed down to the reciever. Override this method to do a deeper search with a UIElement - e.g. a NSMatrix would determine if one of its cells has the focus.
+ */
+- (id)accessibilityFocusedUIElement
+{
+   return [super accessibilityFocusedUIElement];
+}
+
+
+/*  Optional methods to improve performance of accessible objects with large numbers of children or large numbers of UI Elements returned from attributes that return an array (selected children, or visible children, for instance).  The default implementation for these operations will call -accessibilityAttributeValue: to retrieve the entire array of values, and then perform the appropriate operation.  If these methods are implemented, they will be used instead.  For accessibility objects with many children, the results to these methods can sometimes be calculated without generating the entire array of children which can improve performance.
+ */
+
+/* Given an accessibility child of an object, return the index of that child in the parent.
+ */
+- (NSUInteger)accessibilityIndexOfChild:(id)child
+{
+   return swxNSAccessibilityChildrenAttribute
+      .IndexOfValue(self, *accessible, number, child);
+}
+
+/* Return the count of an accessibility array attribute.
+ */
+- (NSUInteger)accessibilityArrayAttributeCount:(NSString *)attribute
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   const wxNSAccessibilityAttribute *pAttribute =
+   findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+         dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+      if (pArrayAttribute)
+      {
+         return pArrayAttribute->GetCount(self, *accessible, number);
+      }
+   }
+
+   return [super accessibilityArrayAttributeCount: attribute];
+}
+
+/* Return a subarray of values of an accessibility array attribute.  Note this method does not take a range.  The max count is the maximum desired number of items requested by an accessibility client.  This number may be beyond the bounds of your array.
+ */
+- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute
+                                         index:(NSUInteger)index
+                                      maxCount:(NSUInteger)maxCount
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   const wxNSAccessibilityAttribute *pAttribute =
+   findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+      dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+      if (pArrayAttribute)
+      {
+         return pArrayAttribute->GetValues
+            (self, *accessible, number, index, maxCount);
+      }
+   }
+
+   return [super accessibilityArrayAttributeValues: attribute
+                                             index: index
+                                          maxCount: maxCount];
+}
+
+@end
+
+void wxOSXCocoaClassAddWXAccessibilityMethods(Class c)
+{
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeNames), (IMP) wxOSX_accessibilityAttributeNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeValue:), (IMP) wxOSX_accessibilityAttributeValue, "@@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIsAttributeSettable:), (IMP) wxOSX_accessibilityIsAttributeSettable, "c@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilitySetValue:forAttribute:), (IMP) wxOSX_accessibilitySetValue_forAttribute, "v@:@@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityParameterizedAttributeNames), (IMP) wxOSX_accessibilityParameterizedAttributeNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeValue:forParameter:), (IMP) wxOSX_accessibilityAttributeValue_forParameter, "@@:@@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityActionNames), (IMP) wxOSX_accessibilityActionNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityActionDescription:), (IMP) wxOSX_accessibilityActionDescription, "@@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityPerformAction:), (IMP) wxOSX_accessibilityPerformAction, "v@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIsIgnored), (IMP) wxOSX_accessibilityIsIgnored, "c@:" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityHitTest:), (IMP) wxOSX_accessibilityHitTest, "@@:{_NSPoint=ff}" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityFocusedUIElement), (IMP) wxOSX_accessibilityFocusedUIElement, "@@:" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIndexOfChild:), (IMP) wxOSX_accessibilityIndexOfChild, "I@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityArrayAttributeCount:), (IMP) wxOSX_accessibilityArrayAttributeCount, "I@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityArrayAttributeValues:index:maxCount:), (IMP) wxOSX_accessibilityArrayAttributeValues_index_maxCount, "@@:@II" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilitySetOverrideValue:forAttribute:), (IMP) wxOSX_accessibilitySetOverrideValue_forAttribute, "c@:@@" )
+}
+
+// static
+void wxAccessible::NotifyEvent
+(int eventType, wxWindow* window, wxAccObject objectType, int objectId)
+{
+#if 0
+   // Leftover NSAccessibility notifications that didn't correspond
+
+   /* Focus notifications
+    */
+NSAccessibilityMainWindowChangedNotification;
+
+   /* Application notifications
+    */
+NSAccessibilityApplicationActivatedNotification;
+NSAccessibilityApplicationDeactivatedNotification;
+NSAccessibilityApplicationHiddenNotification;
+NSAccessibilityApplicationShownNotification;
+
+   /* Window notifications
+    */
+NSAccessibilityWindowCreatedNotification;
+NSAccessibilityWindowDeminiaturizedNotification;
+
+   /* Drawer & sheet notifications
+    */
+NSAccessibilityDrawerCreatedNotification;
+NSAccessibilitySheetCreatedNotification;
+
+   /* Misc notifications
+    */
+NSAccessibilityHelpTagCreatedNotification	;
+NSAccessibilityRowCountChangedNotification;
+
+NSAccessibilityRowExpandedNotification	;
+NSAccessibilityRowCollapsedNotification	;
+
+   /* Cell-table notifications
+    */
+
+   /* Layout area notifications
+    */
+NSAccessibilityUnitsChangedNotification ;
+
+#endif
+
+   enum { maxNotifications = 6 };
+   NSString *notifications[maxNotifications];
+   for(unsigned ii = 0; ii < maxNotifications; ++ii)
+      notifications[ii] = NULL;
+
+   NSString *& notification = notifications[0];
+   NSString *& notification2 = notifications[1];
+
+   switch (eventType)
+   {
+      case wxACC_EVENT_SYSTEM_MOVESIZEEND:
+         notification = NSAccessibilityWindowResizedNotification;
+         break;
+
+      case wxACC_EVENT_SYSTEM_MINIMIZEEND:
+         notification = NSAccessibilityWindowMiniaturizedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_CREATE:
+         notification = NSAccessibilityCreatedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_DESTROY:
+         notification = NSAccessibilityUIElementDestroyedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_NAMECHANGE:
+         notification = NSAccessibilityTitleChangedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_VALUECHANGE:
+         notification = NSAccessibilityValueChangedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_LOCATIONCHANGE:
+         notification = NSAccessibilityMovedNotification;
+         notification2 = NSAccessibilityResizedNotification;
+         break;
+
+      case wxACC_EVENT_SYSTEM_DRAGDROPEND:
+         // Not sure if this is right...
+         if (objectType == wxOBJID_WINDOW)
+            notification = NSAccessibilityWindowMovedNotification;
+         else
+            notification = NSAccessibilityMovedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_FOCUS:
+         // Not sure if this is right...
+         if (objectType == wxOBJID_WINDOW)
+            notification = NSAccessibilityFocusedWindowChangedNotification;
+         else
+            notification = NSAccessibilityFocusedUIElementChangedNotification;
+         break;
+
+         // Selection notifications... quite a mismatch between the
+         // wxWidgets interface and the NS interface.  Just make lots
+         // of notifications to cover the possibilities.
+      case wxACC_EVENT_OBJECT_SELECTION:
+      case wxACC_EVENT_OBJECT_SELECTIONADD:
+      case wxACC_EVENT_OBJECT_SELECTIONREMOVE:
+      case wxACC_EVENT_OBJECT_SELECTIONWITHIN:
+         notifications[0] = NSAccessibilitySelectedTextChangedNotification;
+         notifications[1] = NSAccessibilitySelectedChildrenChangedNotification;
+         notifications[2] = NSAccessibilitySelectedRowsChangedNotification;
+         notifications[3] = NSAccessibilitySelectedColumnsChangedNotification;
+         notifications[4] = NSAccessibilitySelectedCellsChangedNotification;
+         // notifications[5] = NSAccessibilitySelectedChildrenMovedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_REORDER:
+      case wxACC_EVENT_SYSTEM_SCROLLINGEND:
+         notification = NSAccessibilitySelectedChildrenMovedNotification;
+         // maybe?
+         break;
+
+      case wxACC_EVENT_OBJECT_STATECHANGE:
+      case wxACC_EVENT_OBJECT_DESCRIPTIONCHANGE:
+      case wxACC_EVENT_OBJECT_PARENTCHANGE:
+      case wxACC_EVENT_OBJECT_HELPCHANGE:
+      case wxACC_EVENT_OBJECT_DEFACTIONCHANGE:
+      case wxACC_EVENT_OBJECT_ACCELERATORCHANGE:
+         if (objectType == wxOBJID_CLIENT)
+         {
+            notification = NSAccessibilitySelectedChildrenChangedNotification;
+            // maybe?
+            break;
+         }
+         else
+            return;
+
+      case wxACC_EVENT_SYSTEM_SOUND:
+      case wxACC_EVENT_SYSTEM_ALERT:
+      case wxACC_EVENT_SYSTEM_FOREGROUND:
+      case wxACC_EVENT_SYSTEM_MENUSTART:
+      case wxACC_EVENT_SYSTEM_MENUEND:
+      case wxACC_EVENT_SYSTEM_MENUPOPUPSTART:
+      case wxACC_EVENT_SYSTEM_MENUPOPUPEND:
+      case wxACC_EVENT_SYSTEM_CAPTURESTART:
+      case wxACC_EVENT_SYSTEM_CAPTUREEND:
+      case wxACC_EVENT_SYSTEM_MOVESIZESTART:
+
+      case wxACC_EVENT_SYSTEM_CONTEXTHELPSTART:
+      case wxACC_EVENT_SYSTEM_CONTEXTHELPEND:
+      case wxACC_EVENT_SYSTEM_DRAGDROPSTART:
+
+      case wxACC_EVENT_SYSTEM_DIALOGSTART:
+      case wxACC_EVENT_SYSTEM_DIALOGEND:
+      case wxACC_EVENT_SYSTEM_SCROLLINGSTART:
+
+      case wxACC_EVENT_SYSTEM_SWITCHSTART:
+      case wxACC_EVENT_SYSTEM_SWITCHEND:
+      case wxACC_EVENT_SYSTEM_MINIMIZESTART:
+
+      case wxACC_EVENT_OBJECT_SHOW:
+      case wxACC_EVENT_OBJECT_HIDE:
+
+      default:
+         // no equivalents
+      return;
+   }
+
+   id element = nil;
+   if (objectType == wxOBJID_CLIENT)
+   {
+      wxAccessible *pAccessible = window->GetAccessible();
+      if (!pAccessible)
+         return;
+
+      wxAccessible *child = NULL;
+      wxAccStatus status = pAccessible->GetChild(objectId, &child);
+      element = GetUIElement(*pAccessible, objectId, child);
+   }
+   else
+      element = window->GetPeer()->GetWXWidget();
+
+   if (!element)
+      return;
+
+   for(unsigned ii = 0; ii < maxNotifications; ++ii)
+   {
+      NSString *notification = notifications[ii];
+      if (!notification)
+         break;
+      NSAccessibilityPostNotification(element, notification);
+   }
+}
+
 void wxOSXCocoaClassAddWXMethods(Class c)
 {
 
@@ -1779,6 +3629,8 @@ void wxOSXCocoaClassAddWXMethods(Class c)
     {
 #endif
 
+    wxOSX_CLASS_ADD_METHOD(c, @selector(stringValue), (IMP) wxOSX_stringValue, "@@:");
+
     wxOSX_CLASS_ADD_METHOD(c, @selector(mouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(rightMouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(otherMouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
@@ -1832,6 +3684,8 @@ void wxOSXCocoaClassAddWXMethods(Class c)
     wxOSX_CLASS_ADD_METHOD(c, @selector(performDragOperation:), (IMP) wxOSX_performDragOperation, "c@:@" )
 #endif
 
+    wxOSXCocoaClassAddWXAccessibilityMethods(c);
+
 #if OBJC_API_VERSION < 2
     } ;
     static int method_count = WXSIZEOF( wxmethods );
-- 
2.3.2 (Apple Git-55)

